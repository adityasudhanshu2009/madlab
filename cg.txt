
//Bresenhams line
#include<iostream>
using namespace std;
#include<glut.h>
#include<math.h>
int xx, yy, xend, yend;
void myinit()
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0, 500, 0, 500);
	glMatrixMode(GL_MODELVIEW);
}
void setPixel(int x, int y)
{

	glBegin(GL_POINTS);
	glVertex2f(x, y);
	glEnd();
	glFlush();

}
void Bresenhamline()
{
	int dx = abs(xend - xx), dy = abs(yend - yy);
	int p, x, y;
	int twody = 2 * dy, twodyMinustwodx = 2 * (dy - dx);
	int twodx = 2 * dx, twodxMinustwody = 2 * (dx - dy);
	x = xx;
	y = yy;
	glColor3f(1, 0, 0); // Set color to red.
	glPointSize(3); //Set point size to 3
	if (dx > dy)
	{
		//For slope m&lt;1
		p = 2 * dy - dx;
		setPixel(x, y);
		while (x < xend)
		{
			x = x + 1;
			if (p < 0)

				p = p + twody;
			else
			{
				y = y + 1;

				p = p + twodyMinustwodx;
			}

			setPixel(x, y);
			cout << x <<"\t"<< y<<endl;

		}
	}
	else
	{
		//For slope m > 1
		p = 2 * dx - dy;
		setPixel(x, y);
		while (y < yend)
		{
			y = y + 1;
			if (p < 0)

				p = p + twodx;
			else
			{
				x = x + 1;
				p = p + twodxMinustwody;
			}
			setPixel(x, y);
			cout << x << "\t" << y << endl;
		}
	}

}
void display()
{
	glClearColor(1, 1, 1, 1); //Specifies a background RGB color for a display window.
	glClear(GL_COLOR_BUFFER_BIT);// Clear display window.
	Bresenhamline();
	glFlush(); // Process all OpenGL routines as quickly as possible.
}
int main()
{
	glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);// Set display mode.
	glutInitWindowPosition(100, 100); // Set top-left display-window position.
	glutInitWindowSize(500, 500); // Set display-window width and height.
	glutCreateWindow("Bresenham Line Drawing Algorthm ");// Create display window.
	myinit(); // Execute initialization procedure.
	cout<<"Enter co - ordinates of first point :";
	cin>>xx>>yy;
	cout<<"Enter co - ordinates of second point :";
	cin>>xend>>yend;
	glutDisplayFunc(display);//Invokes a function to create a picture within current display window.
	glutMainLoop(); //Executes the computer-graphics program.
	return 0;
}


//2D gasket

#include<stdlib.h>
#include<GL/glut.h>
float v[3][2] = { {-25,-25},{0,25},{25,-25} };
void myinit()
{
	glMatrixMode(GL_PROJECTION_MATRIX);
	glLoadIdentity();
	gluOrtho2D(-50, 50, -50, 50);
	glMatrixMode(GL_MODELVIEW);
}
void display()
{
	glClearColor(1, 1, 1, 1);
	glClear(GL_COLOR_BUFFER_BIT);
	glBegin(GL_LINE_LOOP);
	glVertex2fv(v[0]);
	glVertex2fv(v[1]);
	glVertex2fv(v[2]);
	glEnd();
	float p[2] = { 0,0 };
	int i, n = 5000, j;
	glPointSize(2);
	for (i = 0; i < n; i++)
	{
		j = rand() % 3;
		if (j == 0)
			glColor3f(1, 0, 0);
		else if (j == 1)
			glColor3f(0, 1, 0);
		else
			glColor3f(0, 0, 1);
		p[0] = (p[0] + v[j][0]) / 2;
		p[1] = (p[1] + v[j][1]) / 2;
		glBegin(GL_POINTS);
		glVertex2fv(p);
		glEnd();
		glFlush();
	}
}
void main()
{
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(300, 150);
	glutCreateWindow("2D Sierpinkski Gasket");
	myinit();
	glutDisplayFunc(display);
	glutMainLoop();
}


//traingle rotation
#include<iostream>
using namespace std;
#include<GL/glut.h>
#include<math.h>
float p[3][2] = { {20,20},{40,40},{60,20} };
float xp, yp, theta, rtheta;
void myinit()
{
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(-100, 100, -100, 100);
	glMatrixMode(GL_MODELVIEW);
}
void drawtraiangle()
{
	glBegin(GL_TRIANGLES);
	glVertex2fv(p[0]);
	glVertex2fv(p[1]);
	glVertex2fv(p[2]);
	glEnd();
}

void display()
{
	float x, y;
	glClearColor(1, 1, 1, 1);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1, 0, 0);
	drawtraiangle();
	rtheta = (theta * 3.142) / 180;
	for (int i = 0; i < 3; i++)
	{
		x = p[i][0];
		y = p[i][1];
		p[i][0] = xp + (x - xp) * cos(rtheta) - (y - yp) * sin(rtheta);
		p[i][1] = yp + (x - xp) * sin(rtheta) + (y - yp) * cos(rtheta);
	}
	glColor3f(0, 1, 0);
	drawtraiangle();
	glFlush();
}
void main()
{
	glutInitDisplayMode(GLUT_RGB | GLUT_SINGLE);
	glutInitWindowPosition(100, 100);
	glutInitWindowSize(500, 500);
	glutCreateWindow("Traingle rotation");
	myinit();
	cout << "enter xp,yp and theta" << endl;
	cin >> xp >> yp >> theta;
	glutDisplayFunc(display);
	glutMainLoop();
}

//Scan line

#include<stdlib.h>
#include<stdio.h>
#include<GL/glut.h>
float x1, x2, x3, x4, y1, y2, y3, y4;
void d_menu(int op)
{
	if (op == 1)
		glColor3f(1.0, 0.0, 0.0);
	else if (op == 2)
		glColor3f(0.0, 1.0, 0.0);
	else if (op == 3)
		glColor3f(0.0, 0.0, 1.0);
	else if (op == 4)
		exit(0);
	glutPostRedisplay();
}
void edgedetect(float x1, float y1, float x2, float y2, int* le, int* re)
{
	float mx, x, temp;
	int i;
	if ((y2 - y1) < 0)
	{
		temp = y1; y1 = y2; y2 = temp;
		temp = x1; x1 = x2; x2 = temp;
	}
	if ((y2 - y1) != 0)
		mx = (x2 - x1) / (y2 - y1);
	else
		mx = x2 - x1;
	x = x1;
	for (i = y1; i <= y2; i++)
	{
		if (x < (float)le[i])
			le[i] = (int)x;
		if (x > (float)re[i])
			re[i] = (int)x;
		x += mx;
	}
}
void draw_pixel(int x, int y)
{
	glBegin(GL_POINTS);
	glVertex2i(x, y);
	glEnd();
	glFlush();
}
void scanfill(float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4)
{
	int le[500], re[500];
	int i, y;
	for (i = 0; i < 500; i++)
	{
		le[i] = 500;
		re[i] = 0;
	}
	edgedetect(x1, y1, x2, y2, le, re);
	edgedetect(x2, y2, x3, y3, le, re);
	edgedetect(x3, y3, x4, y4, le, re);
	edgedetect(x4, y4, x1, y1, le, re);
	for (y = 0; y < 500; y++)
	{
		if (le[y] <= re[y])
			for (i = (int)le[y]; i < (int)re[y]; i++)
				draw_pixel(i, y);
	}
}
void display()
{
	x1 = 200.0; y1 = 200.0; x2 = 100.0; y2 = 300.0;
	x3 = 200.0; y3 = 400.0; x4 = 300.0; y4 = 300.0;
	glClear(GL_COLOR_BUFFER_BIT);

	glBegin(GL_LINE_LOOP);
	glVertex2f(x1, y1);
	glVertex2f(x2, y2);
	glVertex2f(x3, y3);
	glVertex2f(x4, y4);
	glEnd();
	scanfill(x1, y1, x2, y2, x3, y3, x4, y4);
	glFlush();
}

void myinit()
{
	glClearColor(1.0, 1.0, 1.0, 1.0);
	glColor3f(1.0, 0.0, 1.0);
	glPointSize(1.0);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluOrtho2D(0.0, 499.0, 0.0, 499.0);
}
void main(int argc, char** argv)
{
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(500, 500);
	glutInitWindowPosition(0, 0);
	glutCreateWindow("Filling a polygon using scanline algorithm");
	glutCreateMenu(d_menu);
	glutAddMenuEntry("Red", 1);
	glutAddMenuEntry("Green", 2);
	glutAddMenuEntry("Blue", 3);
	glutAddMenuEntry("Quit", 4);
	glutAttachMenu(GLUT_RIGHT_BUTTON);
	myinit();
	glutDisplayFunc(display);
	glutMainLoop();
}

//cube rotation

#include<stdlib.h>
#include<stdio.h>
#include<GL/glut.h>
#include<math.h>
float v[8][3] = { {-1,-1,1},{-1,1,1},{1,1,1},{1,-1,1},{-1,-1,-1},{-1,1,-1},{1,1,-1},{1,-1,-1} };
float p[8][3] = { {0,0,1},{0,1,1},{1,1,1},{1,0,1},{0,0,0},{0,1,0},{1,1,0},{1,0,0} };
float theta[3] = { 0,0,0 };
int flag = 2;

void myinit()
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-2, 2, -2, 2, -2, 2);
    glMatrixMode(GL_MODELVIEW);
}
void idlefunc()
{
    theta[flag]++;
    if (theta[flag] > 360)theta[flag] = 0;
    glutPostRedisplay();
}
void mousefunc(int button, int status, int x, int y)
{
    if (button == GLUT_LEFT_BUTTON && status == GLUT_DOWN)
        flag = 2;
    if (button == GLUT_MIDDLE_BUTTON && status == GLUT_DOWN)
        flag = 1;
    if (button == GLUT_RIGHT_BUTTON && status == GLUT_DOWN)
        flag = 0;
}
void drawpoly(int a, int b, int c, int d)
{
    glBegin(GL_POLYGON);
    glColor3fv(p[a]);
    glVertex3fv(v[a]);
    glColor3fv(p[b]);
    glVertex3fv(v[b]);
    glColor3fv(p[c]);
    glVertex3fv(v[c]);
    glColor3fv(p[d]);
    glVertex3fv(v[d]);
    glEnd();
}
void colorcube()
{
    drawpoly(0, 1, 2, 3);
    drawpoly(0, 1, 5, 4);
    drawpoly(1, 5, 6, 2);
    drawpoly(4, 5, 6, 7);
    drawpoly(3, 2, 6, 7);
    drawpoly(0, 4, 7, 3);
}
void display()
{
    glClearColor(1, 1, 1, 1);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor3f(1, 0, 0);
    glEnable(GL_DEPTH_TEST);
    glLoadIdentity();
    glRotatef(theta[0], 1, 0, 0);//x
    glRotatef(theta[1], 0, 1, 0);//y
    glRotatef(theta[2], 0, 0, 1);//z
    colorcube();
    glFlush();
    glutSwapBuffers();
}
void main()
{
    glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_DEPTH);
    glutInitWindowPosition(100, 100);
    glutInitWindowSize(500, 500);
    glutCreateWindow("cube rotation");
    myinit();]
    glutDisplayFunc(display);
    glutMouseFunc(mousefunc);
    glutIdleFunc(idlefunc);
    glutMainLoop();
}


